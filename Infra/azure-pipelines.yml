trigger:
  branches:
    include:
      - feature/*
      - release/*

variables:
  buildConfiguration: 'Release'
  serviceConnection: 'spn-dev-dotnetapi-sub'   # Azure RM Service Connection
  apiProject: 'DotNetCoreApiTemplate.csproj'
  publishDir: '$(Build.ArtifactStagingDirectory)/publish'
  infraDir: 'infra'

stages:
# ======================
# 1. Terraform - Dev
# ======================
- stage: Terraform_Dev
  displayName: "Terraform Infra Deployment on Dev"
  jobs:
  - job: TerraformJob
    displayName: "Run Terraform"
    pool:
      name: Default   # <-- Your self-hosted agent pool name
    steps:
    - checkout: self

    # 1. Install Terraform (skip if already in PATH on agent)
    - task: TerraformInstaller@1
      inputs:
        terraformVersion: '1.8.5'   # or your required version

    - task: AzureCLI@2
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          az account show

    # 2. Clean old .terraform & lock file
    - script: |
        echo "Cleaning old .terraform folder..."
        if exist .terraform rmdir /s /q .terraform
        if exist .terraform.lock.hcl del /q .terraform.lock.hcl
      workingDirectory: $(infraDir)
      displayName: "Clean Terraform Cache"

    # 3. Terraform Init
    - script: |
        terraform init -input=false -upgrade
      workingDirectory: $(infraDir)
      displayName: "Terraform Init"

    # 4. Terraform Validate
    - script: terraform validate
      workingDirectory: $(infraDir)
      displayName: "Terraform Validate"

    # 5. Terraform Plan
    - script: terraform plan -input=false -out=tfplan -var-file=env/dev.tfvars
      workingDirectory: $(infraDir)
      displayName: "Terraform Plan"

    # 6. Publish Plan as Artifact (optional, good practice)
    - publish: $(infraDir)/tfplan
      artifact: terraform-plan

    # 7. Terraform Apply (only on release branch)
    - script: terraform apply -input=false -auto-approve tfplan
      #condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/release/dev'))
      workingDirectory: $(infraDir)
      displayName: "Terraform Apply"


# ======================
# 2. Deploy API - Dev
# ======================
- stage: Deploy_Dev
  displayName: "Deploy API - Dev"
  dependsOn: Terraform_Dev
  jobs:
  - job: BuildAndDeployApiDev
    pool:
      #vmImage: 'windows-latest'
      name: 'Default'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.0.x'
    - task: DotNetCoreCLI@2
      displayName: "Restore"
      inputs:
        command: 'restore'
        projects: '$(apiProject)'
    - task: DotNetCoreCLI@2
      displayName: "Build"
      inputs:
        command: 'build'
        projects: '$(apiProject)'
        arguments: '--configuration $(buildConfiguration)'
    - task: DotNetCoreCLI@2
      displayName: "Publish"
      inputs:
        command: 'publish'
        projects: '$(apiProject)'
        arguments: '--configuration $(buildConfiguration) --output $(publishDir)'
        zipAfterPublish: true
    - task: AzureWebApp@1
      displayName: "Deploy to Dev AppService"
      inputs:
        azureSubscription: $(serviceConnection)
        appType: 'webApp'
        appName: 'asp-dotnetapi-dev'
        package: '$(publishDir)/**/*.zip'

# # ======================
# # 3. Terraform - Test
# # ======================
# - stage: Terraform_Test
#   displayName: "Terraform - Test"
#   dependsOn: Deploy_Dev
#   condition: succeeded()
#   jobs:
#   - deployment: TerraformTest
#     environment: 'test'    # ðŸ‘ˆ manual approval required in DevOps Environments
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: AzureCLI@2
#             displayName: "Terraform Apply - Test"
#             inputs:
#               azureSubscription: $(serviceConnection)
#               scriptType: ps
#               scriptLocation: inlineScript
#               inlineScript: |
#                 cd $(infraDir)
#                 terraform init -input=false
#                 terraform validate
#                 terraform plan -input=false -out=tfplan -var-file="env\test.tfvars"
#                 terraform apply -input=false -auto-approve tfplan

# # ======================
# # 4. Deploy API - Test
# # ======================
# - stage: Deploy_Test
#   displayName: "Deploy API - Test"
#   dependsOn: Terraform_Test
#   condition: succeeded()
#   jobs:
#   - deployment: DeployApiTest
#     environment: 'test'
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: AzureWebApp@1
#             displayName: "Deploy to Test AppService"
#             inputs:
#               azureSubscription: $(serviceConnection)
#               appType: 'webApp'
#               appName: 'your-test-appservice-name'
#               package: '$(publishDir)/**/*.zip'

# # ======================
# # 5. Terraform - Prod
# # ======================
# - stage: Terraform_Prod
#   displayName: "Terraform - Prod"
#   dependsOn: Deploy_Test
#   condition: succeeded()
#   jobs:
#   - deployment: TerraformProd
#     environment: 'prod'   # ðŸ‘ˆ manual approval required
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: AzureCLI@2
#             displayName: "Terraform Apply - Prod"
#             inputs:
#               azureSubscription: $(serviceConnection)
#               scriptType: bash
#               scriptLocation: inlineScript
#               inlineScript: |
#                 cd $(infraDir)
#                 terraform init -input=false
#                 terraform validate
#                 terraform plan -input=false -out=tfplan -var-file="prod.tfvars"
#                 terraform apply -input=false -auto-approve tfplan

# # ======================
# # 6. Deploy API - Prod
# # ======================
# - stage: Deploy_Prod
#   displayName: "Deploy API - Prod"
#   dependsOn: Terraform_Prod
#   condition: succeeded()
#   jobs:
#   - deployment: DeployApiProd
#     environment: 'prod'
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: AzureWebApp@1
#             displayName: "Deploy to Prod AppService"
#             inputs:
#               azureSubscription: $(serviceConnection)
#               appType: 'webApp'
#               appName: 'your-prod-appservice-name'
#               package: '$(publishDir)/**/*.zip'
